//! Pipeline module - orchestrates the code generation process
//!
//! Flow: Scan -> Parse -> Resolve -> Collect -> Generate

use anyhow::{Context, Result};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};

use crate::cargo_expand::{find_cargo_manifest, run_cargo_expand};
use crate::config::Config;
use crate::generator::{
    commands_gen::generate_commands_file, types_gen::generate_types_file, GeneratorContext,
};
use crate::known_types;
use crate::models::{ParseResult, RustEnum, RustStruct, RustType, RustTypeAlias};
use crate::parser::{
    parse_commands, parse_types_expanded_with_aliases, parse_types_with_aliases, ParsedTypes,
};
use crate::resolver::{ModuleResolver, ResolutionResult};
use crate::scanner::Scanner;

/// Result of type collection with potential conflicts
pub struct TypeCollectionResult {
    /// Collected structs reachable from command signatures
    pub structs: Vec<RustStruct>,
    /// Collected enums reachable from command signatures
    pub enums: Vec<RustEnum>,
    /// Collected type aliases reachable from command signatures
    pub aliases: Vec<RustTypeAlias>,
    /// Conflicts: type name -> list of conflicting source files
    pub conflicts: HashMap<String, Vec<PathBuf>>,
    /// Unresolved types: type name -> file where it was used
    pub unresolved: HashMap<String, PathBuf>,
}

/// Main pipeline for code generation
pub struct Pipeline {
    verbose: bool,
}

impl Pipeline {
    pub fn new(verbose: bool) -> Self {
        Self { verbose }
    }

    /// Run the full generation pipeline
    pub fn run(&self, config: &Config) -> Result<()> {
        if self.verbose {
            println!("Scanning directory: {}", config.input.source_dir.display());
        }

        // Step 1: Scan for Rust files
        let rust_files = self.scan_files(config)?;

        if self.verbose {
            println!("Found {} Rust files", rust_files.len());
        }

        // Step 1.5: Optionally run cargo expand for macro-generated types
        let expanded_code = if config.input.use_cargo_expand {
            self.run_cargo_expand(config)?
        } else {
            None
        };

        // Step 2: Parse all files and build resolver
        let (mut parse_result, resolver, expanded_types) =
            self.parse_files(&rust_files, config, expanded_code.as_deref())?;

        // Step 2.5: Filter out Tauri special types (State, Window, etc.) including aliases
        self.filter_tauri_special_args(&mut parse_result.commands, &resolver);

        // Step 3: Collect and resolve types used in commands
        let type_collection =
            self.collect_reachable_types(&parse_result.commands, &resolver, expanded_types.as_ref());

        // Step 4: Check for conflicts
        if !type_collection.conflicts.is_empty() {
            eprintln!("Error: Type name conflicts detected:");
            for (type_name, files) in &type_collection.conflicts {
                eprintln!("  Type '{}' is used from multiple sources:", type_name);
                for file in files {
                    eprintln!("    - {}", file.display());
                }
            }
            anyhow::bail!(
                "Found {} type name conflict(s). Please rename types or use explicit imports to avoid ambiguity.",
                type_collection.conflicts.len()
            );
        }

        // Step 4.5: Warn about unresolved types (likely macro-generated)
        if !type_collection.unresolved.is_empty() {
            println!(
                "Warning: {} type(s) could not be resolved and will not be generated:",
                type_collection.unresolved.len()
            );
            for (type_name, used_in) in &type_collection.unresolved {
                println!("  - '{}' (used in {})", type_name, used_in.display());
            }
            if !config.input.use_cargo_expand {
                println!();
                println!("Hint: These types may be generated by macros (e.g., progenitor, serde, etc.).");
                println!("      To include macro-generated types, add to your config:");
                println!("        [input]");
                println!("        use_cargo_expand = true");
                println!();
            }
        }

        // Summary
        println!(
            "Parsed {} commands, {} structs (used), {} enums (used), {} aliases (used)",
            parse_result.commands.len(),
            type_collection.structs.len(),
            type_collection.enums.len(),
            type_collection.aliases.len()
        );

        // Step 6: Generate TypeScript files
        self.generate_output(
            config,
            &parse_result,
            &type_collection.structs,
            &type_collection.enums,
            &type_collection.aliases,
        )?;

        println!("Done!");

        Ok(())
    }

    /// Step 1: Scan for Rust files
    fn scan_files(&self, config: &Config) -> Result<Vec<PathBuf>> {
        let scanner = Scanner::new(
            config.input.source_dir.clone(),
            config.input.exclude.clone(),
        );
        scanner.scan()
    }

    /// Step 1.5: Run cargo expand if enabled
    fn run_cargo_expand(&self, config: &Config) -> Result<Option<String>> {
        println!("Warning: cargo expand is enabled. This will compile the project and may take a while.");
        println!("Warning: This is used to extract macro-generated types (e.g., from progenitor, serde, etc.)");

        // Find cargo manifest
        let manifest_path = config
            .input
            .cargo_manifest
            .clone()
            .or_else(|| find_cargo_manifest(&config.input.source_dir));

        let manifest_path = match manifest_path {
            Some(p) => p,
            None => {
                eprintln!(
                    "Warning: Could not find Cargo.toml for cargo expand. Skipping macro expansion."
                );
                return Ok(None);
            }
        };

        if self.verbose {
            eprintln!("Info: Using Cargo.toml at: {}", manifest_path.display());
        }

        // Run cargo expand
        let result = run_cargo_expand(&manifest_path)?;

        // Print all warnings
        for warning in &result.warnings {
            eprintln!("{}", warning);
        }

        if result.code.is_empty() {
            eprintln!("Warning: cargo expand produced no output. Continuing with regular parsing.");
            Ok(None)
        } else {
            Ok(Some(result.code))
        }
    }

    /// Step 2: Parse all files and build module resolver
    fn parse_files(
        &self,
        rust_files: &[PathBuf],
        config: &Config,
        expanded_code: Option<&str>,
    ) -> Result<(ParseResult, ModuleResolver, Option<ParsedTypes>)> {
        let mut resolver = ModuleResolver::new();
        let base_path = config.input.source_dir.clone();
        let mut parse_result = ParseResult::new();

        // Store expanded types temporarily - we'll register them AFTER parsing source files
        let mut expanded_types: Option<ParsedTypes> = None;

        // If we have expanded code, parse types from it (but don't register yet)
        if let Some(code) = expanded_code {
            let expanded_path = PathBuf::from("<cargo-expand>");

            match parse_types_expanded_with_aliases(code, &expanded_path) {
                Ok(parsed) => {
                    if self.verbose {
                        eprintln!(
                            "Info: Found {} structs, {} enums, {} aliases from cargo expand",
                            parsed.structs.len(),
                            parsed.enums.len(),
                            parsed.aliases.len()
                        );
                    }

                    expanded_types = Some(parsed);
                }
                Err(e) => {
                    eprintln!(
                        "Warning: Failed to parse types from cargo expand output: {}",
                        e
                    );
                }
            }
        }

        // First, parse all source files - this registers types in the resolver
        for file_path in rust_files {
            let content = fs::read_to_string(file_path)
                .with_context(|| format!("Failed to read file: {}", file_path.display()))?;

            // Build resolver scope for this file
            if let Err(e) = resolver.parse_file(file_path, &content, &base_path) {
                if self.verbose {
                    eprintln!(
                        "Warning: Failed to parse imports in {}: {}",
                        file_path.display(),
                        e
                    );
                }
            }

            // Parse commands
            match parse_commands(&content, file_path) {
                Ok(commands) => {
                    if !commands.is_empty() && self.verbose {
                        println!(
                            "Found {} commands in {}",
                            commands.len(),
                            file_path.display()
                        );
                    }
                    parse_result.commands.extend(commands);
                }
                Err(e) => {
                    eprintln!(
                        "Warning: Failed to parse commands in {}: {}",
                        file_path.display(),
                        e
                    );
                }
            }

        }

        // Now register cargo-expand types, but ONLY if they don't already exist in source files.
        // This prevents the "ambiguous type" bug while still allowing macro-generated types
        // (that don't exist in source) to be resolved.
        if let Some(parsed) = &expanded_types {
            let expanded_path = PathBuf::from("<cargo-expand>");

            for s in &parsed.structs {
                resolver.register_expanded_type_if_missing(&s.name, &expanded_path);
            }
            for e in &parsed.enums {
                resolver.register_expanded_type_if_missing(&e.name, &expanded_path);
            }
            for alias in &parsed.aliases {
                resolver.register_expanded_type_if_missing(&alias.name, &expanded_path);
            }
        }

        Ok((parse_result, resolver, expanded_types))
    }

    /// Step 3: Collect types reachable from command signatures
    fn collect_reachable_types(
        &self,
        commands: &[crate::models::TauriCommand],
        resolver: &ModuleResolver,
        expanded_types: Option<&ParsedTypes>,
    ) -> TypeCollectionResult {
        let mut resolved_types: HashMap<String, PathBuf> = HashMap::new();
        let mut conflicts: HashMap<String, Vec<PathBuf>> = HashMap::new();
        let mut unresolved: HashMap<String, PathBuf> = HashMap::new();
        let mut parsed_files: HashMap<PathBuf, ParsedTypes> = HashMap::new();
        let mut structs: Vec<RustStruct> = Vec::new();
        let mut enums: Vec<RustEnum> = Vec::new();
        let mut aliases: Vec<RustTypeAlias> = Vec::new();
        let mut seen_structs: HashSet<(String, PathBuf)> = HashSet::new();
        let mut seen_enums: HashSet<(String, PathBuf)> = HashSet::new();
        let mut seen_aliases: HashSet<String> = HashSet::new();
        let mut reexport_aliases: HashMap<String, (String, PathBuf)> = HashMap::new();
        let mut to_process: Vec<(String, PathBuf)> = Vec::new();
        let mut processed: HashSet<(String, PathBuf)> = HashSet::new();
        let expanded_path = PathBuf::from("<cargo-expand>");

        if let Some(parsed) = expanded_types {
            parsed_files.insert(expanded_path.clone(), parsed.clone());
        }

        fn add_conflict_path(
            name: &str,
            path: &PathBuf,
            conflicts: &mut HashMap<String, Vec<PathBuf>>,
        ) {
            let entry = conflicts.entry(name.to_string()).or_insert_with(Vec::new);
            if !entry.contains(path) {
                entry.push(path.clone());
            }
        }

        fn resolve_and_enqueue(
            type_name: &str,
            from_file: &Path,
            resolver: &ModuleResolver,
            resolved_types: &mut HashMap<String, PathBuf>,
            conflicts: &mut HashMap<String, Vec<PathBuf>>,
            unresolved: &mut HashMap<String, PathBuf>,
            to_process: &mut Vec<(String, PathBuf)>,
            reexport_aliases: &mut HashMap<String, (String, PathBuf)>,
        ) {
            match resolver.resolve_type(type_name, from_file) {
                ResolutionResult::Found(source) => {
                    let simple_name = type_name.split("::").last().unwrap_or(type_name).to_string();
                    if let Some(existing) = resolved_types.get(&simple_name) {
                        if existing != &source {
                            add_conflict_path(&simple_name, existing, conflicts);
                            add_conflict_path(&simple_name, &source, conflicts);
                        }
                    } else {
                        resolved_types.insert(simple_name.clone(), source.clone());
                        to_process.push((simple_name, source));
                    }
                }
                ResolutionResult::FoundWithAlias(source, original_name) => {
                    let alias_name = type_name.split("::").last().unwrap_or(type_name).to_string();
                    if let Some(existing) = resolved_types.get(&alias_name) {
                        if existing != &source {
                            add_conflict_path(&alias_name, existing, conflicts);
                            add_conflict_path(&alias_name, &source, conflicts);
                        }
                    } else {
                        resolved_types.insert(alias_name.clone(), source.clone());
                    }
                    reexport_aliases
                        .entry(alias_name)
                        .or_insert_with(|| (original_name.clone(), source.clone()));
                    to_process.push((original_name, source));
                }
                ResolutionResult::Ambiguous(paths) => {
                    let simple_name = type_name.split("::").last().unwrap_or(type_name).to_string();
                    for path in paths {
                        add_conflict_path(&simple_name, &path, conflicts);
                    }
                }
                ResolutionResult::NotFound => {
                    let simple_name = type_name.split("::").last().unwrap_or(type_name).to_string();
                    unresolved
                        .entry(simple_name)
                        .or_insert_with(|| from_file.to_path_buf());
                }
            }
        }

        for cmd in commands {
            let cmd_file = &cmd.source_file;
            for arg in &cmd.args {
                for t in collect_custom_types_from_rust_type(&arg.ty) {
                    resolve_and_enqueue(
                        &t,
                        cmd_file,
                        resolver,
                        &mut resolved_types,
                        &mut conflicts,
                        &mut unresolved,
                        &mut to_process,
                        &mut reexport_aliases,
                    );
                }
            }
            if let Some(ref ret_type) = cmd.return_type {
                for t in collect_custom_types_from_rust_type(ret_type) {
                    resolve_and_enqueue(
                        &t,
                        cmd_file,
                        resolver,
                        &mut resolved_types,
                        &mut conflicts,
                        &mut unresolved,
                        &mut to_process,
                        &mut reexport_aliases,
                    );
                }
            }
        }

        while let Some((type_name, type_file)) = to_process.pop() {
            let key = (type_name.clone(), type_file.clone());
            if processed.contains(&key) {
                continue;
            }
            processed.insert(key);

            if type_file != expanded_path && !parsed_files.contains_key(&type_file) {
                match fs::read_to_string(&type_file) {
                    Ok(content) => match parse_types_with_aliases(&content, &type_file) {
                        Ok(parsed) => {
                            parsed_files.insert(type_file.clone(), parsed);
                        }
                        Err(e) => {
                            eprintln!(
                                "Warning: Failed to parse types in {}: {}",
                                type_file.display(),
                                e
                            );
                            continue;
                        }
                    },
                    Err(e) => {
                        eprintln!(
                            "Warning: Failed to read file for types {}: {}",
                            type_file.display(),
                            e
                        );
                        continue;
                    }
                }
            }

            let parsed = match parsed_files.get(&type_file) {
                Some(parsed) => parsed,
                None => continue,
            };

            if let Some(s) = parsed.structs.iter().find(|s| s.name == type_name) {
                if seen_structs.insert((s.name.clone(), type_file.clone())) {
                    structs.push(s.clone());
                }

                for field in &s.fields {
                    for t in collect_custom_types_from_rust_type(&field.ty) {
                        resolve_and_enqueue(
                            &t,
                            &type_file,
                            resolver,
                            &mut resolved_types,
                            &mut conflicts,
                            &mut unresolved,
                            &mut to_process,
                            &mut reexport_aliases,
                        );
                    }
                }
                continue;
            }

            if let Some(e) = parsed.enums.iter().find(|e| e.name == type_name) {
                if seen_enums.insert((e.name.clone(), type_file.clone())) {
                    enums.push(e.clone());
                }

                for variant in &e.variants {
                    let nested = match &variant.data {
                        crate::models::VariantData::Unit => vec![],
                        crate::models::VariantData::Tuple(types) => types
                            .iter()
                            .flat_map(collect_custom_types_from_rust_type)
                            .collect(),
                        crate::models::VariantData::Struct(fields) => fields
                            .iter()
                            .flat_map(|f| collect_custom_types_from_rust_type(&f.ty))
                            .collect(),
                    };
                    for t in nested {
                        resolve_and_enqueue(
                            &t,
                            &type_file,
                            resolver,
                            &mut resolved_types,
                            &mut conflicts,
                            &mut unresolved,
                            &mut to_process,
                            &mut reexport_aliases,
                        );
                    }
                }
                continue;
            }

            if let Some(alias) = parsed.aliases.iter().find(|a| a.name == type_name) {
                if seen_aliases.insert(alias.name.clone()) {
                    aliases.push(alias.clone());
                }

                for t in collect_custom_types_from_rust_type(&alias.target) {
                    resolve_and_enqueue(
                        &t,
                        &alias.source_file,
                        resolver,
                        &mut resolved_types,
                        &mut conflicts,
                        &mut unresolved,
                        &mut to_process,
                        &mut reexport_aliases,
                    );
                }
            }
        }

        for (alias_name, (original_name, source_file)) in reexport_aliases {
            if seen_aliases.contains(&alias_name) {
                continue;
            }

            let generics = parsed_files
                .get(&source_file)
                .and_then(|parsed| {
                    parsed
                        .structs
                        .iter()
                        .find(|s| s.name == original_name)
                        .map(|s| s.generics.clone())
                        .or_else(|| {
                            parsed
                                .enums
                                .iter()
                                .find(|e| e.name == original_name)
                                .map(|e| e.generics.clone())
                        })
                })
                .unwrap_or_default();

            aliases.push(RustTypeAlias {
                name: alias_name,
                generics,
                target: RustType::Custom(original_name),
                source_file,
            });
        }

        TypeCollectionResult {
            structs,
            enums,
            aliases,
            conflicts,
            unresolved,
        }
    }

    /// Step 6: Generate TypeScript output files
    fn generate_output(
        &self,
        config: &Config,
        parse_result: &ParseResult,
        filtered_structs: &[RustStruct],
        filtered_enums: &[RustEnum],
        aliases: &[RustTypeAlias],
    ) -> Result<()> {
        // Ensure output directories exist before writing files
        config.ensure_output_directories()?;

        // Create generator context
        let mut ctx = GeneratorContext::new(config.naming.clone());

        for s in filtered_structs {
            ctx.register_type(&s.name);
        }
        for e in filtered_enums {
            ctx.register_type(&e.name);
        }
        for alias in aliases {
            ctx.register_type(&alias.name);
        }

        // Generate types.ts
        let types_content = generate_types_file(filtered_structs, filtered_enums, aliases, &ctx);

        fs::write(&config.output.types_file, &types_content).with_context(|| {
            format!(
                "Failed to write types file: {}",
                config.output.types_file.display()
            )
        })?;

        println!("Generated: {}", config.output.types_file.display());

        // Generate commands.ts
        let commands_content = generate_commands_file(
            &parse_result.commands,
            &config.output.types_file,
            &config.output.commands_file,
            &ctx,
        );

        fs::write(&config.output.commands_file, &commands_content).with_context(|| {
            format!(
                "Failed to write commands file: {}",
                config.output.commands_file.display()
            )
        })?;

        println!("Generated: {}", config.output.commands_file.display());

        Ok(())
    }
    
    /// Step 2.5: Filter out Tauri special types from command arguments
    /// This handles both direct uses (State<T>) and type aliases (type MyState = State<T>)
    fn filter_tauri_special_args(
        &self,
        commands: &mut [crate::models::TauriCommand],
        resolver: &ModuleResolver,
    ) {
        for cmd in commands.iter_mut() {
            cmd.args.retain(|arg| {
                // Get the base type name from the RustType
                let type_name = match &arg.ty {
                    RustType::Custom(name) => {
                        // Extract just the type name (without path)
                        name.split("::").last().unwrap_or(name).to_string()
                    }
                    RustType::Unknown(name) => {
                        name.split("::").last().unwrap_or(name).to_string()
                    }
                    _ => return true, // Keep primitives, Vec, Option, etc.
                };
                
                // Check if it's directly a Tauri special type
                if known_types::is_tauri_special_type(&type_name) {
                    return false;
                }
                
                // Check if it's an alias to a Tauri special type
                if let Some(target) = resolver.resolve_alias_target(&type_name, &cmd.source_file) {
                    if known_types::is_tauri_special_type(&target) {
                        return false;
                    }
                }
                
                true
            });
        }
    }
}

/// Collect custom type names from a RustType (returns a Vec)
fn collect_custom_types_from_rust_type(ty: &RustType) -> Vec<String> {
    let mut types = HashSet::new();
    collect_custom_types_recursive(ty, &mut types);
    let mut result: Vec<String> = types.into_iter().collect();
    result.sort();
    result
}

fn collect_custom_types_recursive(ty: &RustType, types: &mut HashSet<String>) {
    match ty {
        RustType::Custom(name) => {
             types.insert(name.clone());
        }
        RustType::Vec(inner) => collect_custom_types_recursive(inner, types),
        RustType::Option(inner) => collect_custom_types_recursive(inner, types),
        RustType::Result(ok) => collect_custom_types_recursive(ok, types),
        RustType::HashMap { key, value } => {
            collect_custom_types_recursive(key, types);
            collect_custom_types_recursive(value, types);
        }
        RustType::Tuple(tuple_types) => {
            for t in tuple_types {
                collect_custom_types_recursive(t, types);
            }
        }
        _ => {}
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::{CommandArg, TauriCommand};

    fn test_path() -> PathBuf {
        PathBuf::from("test.rs")
    }

    #[test]
    fn test_collect_custom_types_simple() {
        let ty = RustType::Custom("User".to_string());
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["User"]);
    }

    #[test]
    fn test_collect_custom_types_primitive() {
        let ty = RustType::Primitive("String".to_string());
        let types = collect_custom_types_from_rust_type(&ty);
        assert!(types.is_empty());
    }

    #[test]
    fn test_collect_custom_types_vec() {
        let ty = RustType::Vec(Box::new(RustType::Custom("Item".to_string())));
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["Item"]);
    }

    #[test]
    fn test_collect_custom_types_option() {
        let ty = RustType::Option(Box::new(RustType::Custom("User".to_string())));
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["User"]);
    }

    #[test]
    fn test_collect_custom_types_result() {
        let ty = RustType::Result(Box::new(RustType::Custom("Response".to_string())));
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["Response"]);
    }

    #[test]
    fn test_collect_custom_types_hashmap() {
        let ty = RustType::HashMap {
            key: Box::new(RustType::Primitive("String".to_string())),
            value: Box::new(RustType::Custom("User".to_string())),
        };
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["User"]);
    }

    #[test]
    fn test_collect_custom_types_tuple() {
        let ty = RustType::Tuple(vec![
            RustType::Custom("User".to_string()),
            RustType::Custom("Item".to_string()),
            RustType::Primitive("i32".to_string()),
        ]);
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["Item", "User"]);
    }

    #[test]
    fn test_collect_custom_types_nested() {
        let ty = RustType::Vec(Box::new(RustType::Option(Box::new(RustType::Custom(
            "User".to_string(),
        )))));
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["User"]);
    }

    #[test]
    fn test_collect_custom_types_no_duplicates() {
        let ty = RustType::Tuple(vec![
            RustType::Custom("User".to_string()),
            RustType::Custom("User".to_string()),
        ]);
        let types = collect_custom_types_from_rust_type(&ty);
        assert_eq!(types, vec!["User"]);
    }

    fn write_file(path: &std::path::Path, content: &str) {
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent).unwrap();
        }
        std::fs::write(path, content).unwrap();
    }

    #[test]
    fn test_collect_reachable_types_from_commands() {
        let pipeline = Pipeline::new(false);
        let temp_dir = tempfile::tempdir().unwrap();
        let src_dir = temp_dir.path().join("src");

        let types_path = src_dir.join("types.rs");
        let types_code = r#"
            pub struct Request { pub data: String }
            pub struct Response { pub result: i32 }
        "#;
        write_file(&types_path, types_code);

        let mut resolver = ModuleResolver::new();
        resolver.parse_file(&types_path, types_code, &src_dir).unwrap();

        let commands = vec![TauriCommand {
            name: "process".to_string(),
            args: vec![CommandArg {
                name: "req".to_string(),
                ty: RustType::Custom("Request".to_string()),
            }],
            return_type: Some(RustType::Custom("Response".to_string())),
            source_file: types_path.clone(),
            rename_all: None,
        }];

        let result = pipeline.collect_reachable_types(&commands, &resolver, None);

        assert!(result.conflicts.is_empty());
        assert!(result.structs.iter().any(|s| s.name == "Request"));
        assert!(result.structs.iter().any(|s| s.name == "Response"));
    }

    #[test]
    fn test_collect_reachable_types_includes_aliases() {
        let pipeline = Pipeline::new(false);
        let temp_dir = tempfile::tempdir().unwrap();
        let src_dir = temp_dir.path().join("src");

        let types_path = src_dir.join("types.rs");
        let types_code = r#"
            pub struct User { pub id: i32 }
            pub type UserAlias = User;
        "#;
        write_file(&types_path, types_code);

        let mut resolver = ModuleResolver::new();
        resolver.parse_file(&types_path, types_code, &src_dir).unwrap();

        let commands = vec![TauriCommand {
            name: "get_user".to_string(),
            args: vec![CommandArg {
                name: "user".to_string(),
                ty: RustType::Custom("UserAlias".to_string()),
            }],
            return_type: None,
            source_file: types_path.clone(),
            rename_all: None,
        }];

        let result = pipeline.collect_reachable_types(&commands, &resolver, None);

        assert!(result.aliases.iter().any(|a| a.name == "UserAlias"));
        assert!(result.structs.iter().any(|s| s.name == "User"));
    }

    #[test]
    fn test_collect_reachable_types_detects_conflicts() {
        let pipeline = Pipeline::new(false);
        let temp_dir = tempfile::tempdir().unwrap();
        let src_dir = temp_dir.path().join("src");

        let a_path = src_dir.join("a.rs");
        let b_path = src_dir.join("b.rs");
        let cmd_path = src_dir.join("commands.rs");
        let code_a = "pub struct User { pub id: i32 }";
        let code_b = "pub struct User { pub name: String }";
        let cmd_code = "fn some_fn() {}";

        write_file(&a_path, code_a);
        write_file(&b_path, code_b);
        write_file(&cmd_path, cmd_code);

        let mut resolver = ModuleResolver::new();
        resolver.parse_file(&a_path, code_a, &src_dir).unwrap();
        resolver.parse_file(&b_path, code_b, &src_dir).unwrap();
        resolver.parse_file(&cmd_path, cmd_code, &src_dir).unwrap();

        let commands = vec![TauriCommand {
            name: "get_user".to_string(),
            args: vec![],
            return_type: Some(RustType::Custom("User".to_string())),
            source_file: cmd_path,
            rename_all: None,
        }];

        let result = pipeline.collect_reachable_types(&commands, &resolver, None);

        assert!(result.conflicts.contains_key("User"));
    }

    #[test]
    fn test_pipeline_verbose_mode() {
        let pipeline = Pipeline::new(true);
        assert!(pipeline.verbose);

        let pipeline = Pipeline::new(false);
        assert!(!pipeline.verbose);
    }


    #[test]
    fn test_filter_tauri_special_types() {
        let pipeline = Pipeline::new(false);
        let resolver = ModuleResolver::new();

        // Create a command with special Tauri types
        let mut commands = vec![TauriCommand {
            name: "test_command".to_string(),
            args: vec![
                CommandArg {
                    name: "state".to_string(),
                    ty: RustType::Custom("State".to_string()),
                },
                CommandArg {
                    name: "window".to_string(),
                    ty: RustType::Custom("Window".to_string()),
                },
                CommandArg {
                    name: "id".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
            ],
            return_type: None,
            source_file: test_path(),
            rename_all: None,
        }];

        pipeline.filter_tauri_special_args(&mut commands, &resolver);

        // State and Window should be filtered out
        assert_eq!(commands[0].args.len(), 1);
        assert_eq!(commands[0].args[0].name, "id");
    }

    #[test]
    fn test_filter_tauri_app_handle() {
        let pipeline = Pipeline::new(false);
        let resolver = ModuleResolver::new();

        let mut commands = vec![TauriCommand {
            name: "with_app".to_string(),
            args: vec![
                CommandArg {
                    name: "app".to_string(),
                    ty: RustType::Custom("AppHandle".to_string()),
                },
                CommandArg {
                    name: "data".to_string(),
                    ty: RustType::Primitive("String".to_string()),
                },
            ],
            return_type: None,
            source_file: test_path(),
            rename_all: None,
        }];

        pipeline.filter_tauri_special_args(&mut commands, &resolver);

        // AppHandle should be filtered out
        assert_eq!(commands[0].args.len(), 1);
        assert_eq!(commands[0].args[0].name, "data");
    }

    #[test]
    fn test_filter_tauri_special_types_via_alias() {
        let pipeline = Pipeline::new(false);
        let mut resolver = ModuleResolver::new();

        // Register a type alias: type MyState = State<AppState>
        let code = "pub type MyState<'a> = State<'a, AppState>;";
        let path = test_path();
        resolver.parse_file(&path, code, &PathBuf::from(".")).unwrap();

        let mut commands = vec![TauriCommand {
            name: "aliased_command".to_string(),
            args: vec![
                CommandArg {
                    name: "state".to_string(),
                    ty: RustType::Custom("MyState".to_string()),
                },
                CommandArg {
                    name: "id".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
            ],
            return_type: None,
            source_file: path.clone(),
            rename_all: None,
        }];

        pipeline.filter_tauri_special_args(&mut commands, &resolver);

        // MyState (alias to State) should be filtered out
        assert_eq!(commands[0].args.len(), 1);
        assert_eq!(commands[0].args[0].name, "id");
    }
}
