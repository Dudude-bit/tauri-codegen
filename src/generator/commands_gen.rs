use crate::parser::{RustType, TauriCommand};
use std::collections::HashSet;
use std::path::Path;

use super::{
    type_mapper::{rust_to_typescript, to_camel_case},
    GeneratorContext,
};

/// Generate TypeScript commands file content
pub fn generate_commands_file(
    commands: &[TauriCommand],
    types_file_path: &Path,
    commands_file_path: &Path,
    ctx: &GeneratorContext,
) -> String {
    let mut output = String::new();

    // Add header comment
    output.push_str("// This file was auto-generated by tauri-codegen\n");
    output.push_str("// Do not edit this file manually\n\n");

    // Add Tauri import
    output.push_str("import { invoke } from \"@tauri-apps/api/core\";\n");

    // Collect all custom types used in commands
    let used_types = collect_used_types(commands, ctx);

    if !used_types.is_empty() {
        // Calculate relative import path from commands file to types file
        let import_path = calculate_relative_import(types_file_path, commands_file_path);
        let types_list: Vec<_> = used_types.into_iter().collect();
        output.push_str(&format!(
            "import type {{ {} }} from \"{}\";\n",
            types_list.join(", "),
            import_path
        ));
    }

    output.push('\n');

    // Generate function for each command
    for cmd in commands {
        output.push_str(&generate_command_function(cmd, ctx));
        output.push('\n');
    }

    output
}

/// Collect all custom type names used in commands
fn collect_used_types(commands: &[TauriCommand], ctx: &GeneratorContext) -> HashSet<String> {
    let mut types = HashSet::new();

    for cmd in commands {
        // Check arguments
        for arg in &cmd.args {
            collect_types_from_rust_type(&arg.ty, ctx, &mut types);
        }

        // Check return type
        if let Some(ret_type) = &cmd.return_type {
            collect_types_from_rust_type(ret_type, ctx, &mut types);
        }
    }

    types
}

/// Recursively collect custom type names from a RustType
fn collect_types_from_rust_type(
    ty: &RustType,
    ctx: &GeneratorContext,
    types: &mut HashSet<String>,
) {
    match ty {
        RustType::Custom(name) if ctx.is_custom_type(name) => {
            types.insert(ctx.format_type_name(name));
        }
        RustType::Vec(inner) => collect_types_from_rust_type(inner, ctx, types),
        RustType::Option(inner) => collect_types_from_rust_type(inner, ctx, types),
        RustType::Result(ok) => {
            collect_types_from_rust_type(ok, ctx, types);
        }
        RustType::HashMap { key, value } => {
            collect_types_from_rust_type(key, ctx, types);
            collect_types_from_rust_type(value, ctx, types);
        }
        RustType::Tuple(types_vec) => {
            for t in types_vec {
                collect_types_from_rust_type(t, ctx, types);
            }
        }
        _ => {}
    }
}

/// Generate a TypeScript function for a Tauri command
fn generate_command_function(cmd: &TauriCommand, ctx: &GeneratorContext) -> String {
    let mut output = String::new();

    // Function name in camelCase
    let fn_name = to_camel_case(&cmd.name);
    let fn_name = ctx.format_function_name(&fn_name);

    // Generate parameter list
    let params = generate_params(&cmd.args, ctx);

    // Generate return type
    let return_type = generate_return_type(&cmd.return_type, ctx);

    // Generate function signature
    output.push_str(&format!(
        "export async function {}({}): Promise<{}> {{\n",
        fn_name, params, return_type
    ));

    // Generate invoke call
    if cmd.args.is_empty() {
        output.push_str(&format!(
            "  return invoke<{}>(\"{}\");\n",
            return_type, cmd.name
        ));
    } else {
        let args_obj = generate_args_object(&cmd.args);
        output.push_str(&format!(
            "  return invoke<{}>(\"{}\", {{ {} }});\n",
            return_type, cmd.name, args_obj
        ));
    }

    output.push_str("}\n");

    output
}

/// Generate TypeScript parameter list
fn generate_params(args: &[crate::parser::CommandArg], ctx: &GeneratorContext) -> String {
    args.iter()
        .map(|arg| {
            let param_name = to_camel_case(&arg.name);
            let param_type = rust_to_typescript(&arg.ty, ctx);
            format!("{}: {}", param_name, param_type)
        })
        .collect::<Vec<_>>()
        .join(", ")
}

/// Generate TypeScript return type
fn generate_return_type(return_type: &Option<RustType>, ctx: &GeneratorContext) -> String {
    match return_type {
        Some(ty) => rust_to_typescript(ty, ctx),
        None => "void".to_string(),
    }
}

/// Generate the arguments object for invoke
fn generate_args_object(args: &[crate::parser::CommandArg]) -> String {
    args.iter()
        .map(|arg| {
            let param_name = to_camel_case(&arg.name);
            // If the Rust name (snake_case) differs from camelCase, use object shorthand
            if arg.name == param_name {
                param_name
            } else {
                // Need to map camelCase param to snake_case key
                format!("{}: {}", arg.name, param_name)
            }
        })
        .collect::<Vec<_>>()
        .join(", ")
}

/// Calculate relative import path from types file to commands file
fn calculate_relative_import(types_file: &Path, commands_file: &Path) -> String {
    // Get the directory of the commands file
    let commands_dir = commands_file.parent().unwrap_or(Path::new("."));

    // Get types file relative to commands dir
    if let Ok(relative) = types_file.strip_prefix(commands_dir) {
        let path = relative.with_extension("");
        let path_str = path.to_string_lossy();
        if path_str.starts_with('.') {
            path_str.to_string()
        } else {
            format!("./{}", path_str)
        }
    } else {
        // Files are in different directories, compute relative path
        let types_name = types_file.file_stem().unwrap_or_default();
        format!("./{}", types_name.to_string_lossy())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::NamingConfig;
    use crate::parser::CommandArg;

    #[test]
    fn test_generate_simple_command() {
        let cmd = TauriCommand {
            name: "get_user".to_string(),
            args: vec![CommandArg {
                name: "id".to_string(),
                ty: RustType::Primitive("i32".to_string()),
            }],
            return_type: Some(RustType::Custom("User".to_string())),
        };

        let mut ctx = GeneratorContext::new(NamingConfig::default());
        ctx.register_type("User");

        let output = generate_command_function(&cmd, &ctx);

        assert!(output.contains("export async function getUser"));
        assert!(output.contains("id: number"));
        assert!(output.contains("Promise<User>"));
        assert!(output.contains("invoke<User>(\"get_user\""));
    }
}

