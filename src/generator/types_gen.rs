use crate::parser::{RustEnum, RustStruct, VariantData};

use super::{type_mapper::rust_to_typescript, GeneratorContext};

/// Generate TypeScript types file content
pub fn generate_types_file(
    structs: &[RustStruct],
    enums: &[RustEnum],
    ctx: &GeneratorContext,
) -> String {
    let mut output = String::new();

    // Add header comment
    output.push_str("// This file was auto-generated by tauri-codegen\n");
    output.push_str("// Do not edit this file manually\n\n");

    // Generate interfaces for structs
    for s in structs {
        output.push_str(&generate_interface(s, ctx));
        output.push('\n');
    }

    // Generate types for enums
    for e in enums {
        output.push_str(&generate_enum_type(e, ctx));
        output.push('\n');
    }

    output
}

/// Generate a TypeScript interface from a Rust struct
fn generate_interface(s: &RustStruct, ctx: &GeneratorContext) -> String {
    let mut output = String::new();

    let interface_name = ctx.format_type_name(&s.name);
    output.push_str(&format!("export interface {} {{\n", interface_name));

    for field in &s.fields {
        let ts_type = rust_to_typescript(&field.ty, ctx);
        let field_name = to_camel_case_field(&field.name);
        output.push_str(&format!("  {}: {};\n", field_name, ts_type));
    }

    output.push_str("}\n");

    output
}

/// Generate a TypeScript type from a Rust enum
fn generate_enum_type(e: &RustEnum, ctx: &GeneratorContext) -> String {
    let mut output = String::new();

    let type_name = ctx.format_type_name(&e.name);

    // Check if this is a simple enum (all unit variants)
    let is_simple = e.variants.iter().all(|v| matches!(v.data, VariantData::Unit));

    if is_simple {
        // Generate as string union type
        let variants: Vec<_> = e
            .variants
            .iter()
            .map(|v| format!("\"{}\"", v.name))
            .collect();

        output.push_str(&format!(
            "export type {} = {};\n",
            type_name,
            variants.join(" | ")
        ));
    } else {
        // Generate as discriminated union
        let mut variant_types = Vec::new();

        for variant in &e.variants {
            match &variant.data {
                VariantData::Unit => {
                    variant_types.push(format!("{{ type: \"{}\" }}", variant.name));
                }
                VariantData::Tuple(types) => {
                    let ts_types: Vec<_> = types
                        .iter()
                        .enumerate()
                        .map(|(i, t)| {
                            let ts_type = rust_to_typescript(t, ctx);
                            format!("value{}: {}", i, ts_type)
                        })
                        .collect();

                    variant_types.push(format!(
                        "{{ type: \"{}\"; {} }}",
                        variant.name,
                        ts_types.join("; ")
                    ));
                }
                VariantData::Struct(fields) => {
                    let ts_fields: Vec<_> = fields
                        .iter()
                        .map(|f| {
                            let ts_type = rust_to_typescript(&f.ty, ctx);
                            format!("{}: {}", to_camel_case_field(&f.name), ts_type)
                        })
                        .collect();

                    variant_types.push(format!(
                        "{{ type: \"{}\"; {} }}",
                        variant.name,
                        ts_fields.join("; ")
                    ));
                }
            }
        }

        output.push_str(&format!(
            "export type {} =\n  | {};\n",
            type_name,
            variant_types.join("\n  | ")
        ));
    }

    output
}

/// Convert snake_case to camelCase for field names
fn to_camel_case_field(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = false;

    for (i, c) in s.chars().enumerate() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else if i == 0 {
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::NamingConfig;
    use crate::parser::{RustType, StructField};

    #[test]
    fn test_generate_simple_interface() {
        let s = RustStruct {
            name: "User".to_string(),
            fields: vec![
                StructField {
                    name: "id".to_string(),
                    ty: RustType::Primitive("i32".to_string()),
                },
                StructField {
                    name: "name".to_string(),
                    ty: RustType::Primitive("String".to_string()),
                },
            ],
        };

        let ctx = GeneratorContext::new(NamingConfig::default());
        let output = generate_interface(&s, &ctx);

        assert!(output.contains("export interface User"));
        assert!(output.contains("id: number"));
        assert!(output.contains("name: string"));
    }
}

